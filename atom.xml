<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Fantasy Ace's blog]]></title>
  <subtitle><![CDATA[当你的才华还撑不起你的野心时，你就应该静下心来学习。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://fantasynew.github.io/"/>
  <updated>2014-05-04T14:40:07.924Z</updated>
  <id>http://fantasynew.github.io/</id>
  
  <author>
    <name><![CDATA[Fantasy Ace]]></name>
    <email><![CDATA[jingjiewuying@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[线程安全和不可变性]]></title>
    <link href="http://fantasynew.github.io/2014/04/21/thread-safety-and-immutability/"/>
    <id>http://fantasynew.github.io/2014/04/21/thread-safety-and-immutability/</id>
    <published>2014-04-21T14:06:44.000Z</published>
    <updated>2014-05-04T14:40:01.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/thread-safety-and-immutability.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/thread-safety-and-immutability.html</a></p>
<p>　　只有当多个线程访问相同的资源，并且它们中的一个或多个线程对资源进行写操作时才会出现竞态条件。多个线程读取相同的资源时竞态条件不会出现。</p>
<p>　　我们可以通过创建不可变的共享对象来确保线程之间分享的对象不会被其它线程更新，以确保线程安全。例子如下：</p>
<blockquote>
<p><code>public class ImmutableValue{</code>  </p>
<p>　　<code>private int value = 0;</code>  </p>
<p>　　<code>public ImmutableValue(int value){</code><br>　　　　<code>this.value = value;</code><br>　　<code>}</code>  </p>
<p>　　<code>public int getValue(){</code><br>　　　　<code>return this.value;</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　注意ImmutableValue实例的value属性是在构造函数中赋值的，并且里面没有setter方法。一旦ImmutableValue实例被创建就不能改变它的value值，它是不可变的。不过，你可以使用 getValue()方法读取它的value值。</p>
<p>　　如果你需要对ImmutableValue实例执行操作，可以通过返回一个带有操作结果的新实例来实现。下面是一个加法操作的例子：</p>
<blockquote>
<p><code>public class ImmutableValue{</code>  </p>
<p>　　<code>private int value = 0;</code>  </p>
<p>　　<code>public ImmutableValue(int value){</code><br>　　　　<code>this.value = value;</code><br>　　<code>}</code>  </p>
<p>　　<code>public int getValue(){</code><br>　　　　<code>return this.value;</code><br>　　<code>}</code>  </p>
<p>　　<code>public ImmutableValue add(int valueToAdd){</code><br>　　　　<code>return new ImmutableValue(this.value + valueToAdd);</code><br>　　<code>}</code>  </p>
<p><code>}</code>  </p>
</blockquote>
<p>　　注意add()方法返回了一个带有加法操作结果的新ImmutableValue实例，而不是直接对自己的value值进行加法操作。</p>
<h2 id="引用不是线程安全的！">引用不是线程安全的！</h2>
<p>　　<br>　　需要记住的是，即使一个对象是线程安全的不可变对象，这个对象的引用也可能不是线程安全的。看下面的例子：</p>
<blockquote>
<p><code>public void Calculator{</code><br>　　<code>private ImmutableValue currentValue = null;</code>  </p>
<p>　　<code>public ImmutableValue getValue(){</code><br>　　　　<code>return currentValue;</code><br>　　<code>}</code>  </p>
<p>　　<code>public void setValue(ImmutableValue newValue){</code><br>　　　　<code>this.currentValue = newValue;</code><br>　　<code>}</code>  </p>
<p>　　<code>public void add(int newValue){</code><br>　　　　<code>this.currentValue = this.currentValue.add(newValue);</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　Calculator类有一个ImmutableValue 实例的引用，注意通过setValue()和add()这两个方法都可能会改变这个引用。所以即使Calculator类在内部使用了不可变的对象，它自己却不是不可变的也就不是线程安全的。换句话说：ImmutableValue类是线程安全的，但是对它的使用却不是，当你尝试使用不可变性来达到线程安全的目标时需要牢记这一点。</p>
<p>　　为了保证Calculator的线程安全你只需要声明getValue(), setValue()和 add()方法为synchronized的即可。</p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程安全" scheme="http://fantasynew.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="不可变性" scheme="http://fantasynew.github.io/tags/%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线程安全和资源共享]]></title>
    <link href="http://fantasynew.github.io/2014/04/18/thread-safety-and-shared-resources/"/>
    <id>http://fantasynew.github.io/2014/04/18/thread-safety-and-shared-resources/</id>
    <published>2014-04-18T14:06:44.000Z</published>
    <updated>2014-05-04T14:07:46.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/thread-safety.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/thread-safety.html</a></p>
<p>　　代码被多个线程同时调用还很安全被称作线程安全的。一段线程安全的代码不会存在竞态条件，竞态条件只存在于多个线程同时更新共享资源的情况下，所以了解java线程运行时都共享哪些资源是非常重要的。</p>
<h2 id="局部变量">局部变量</h2>
<p>　　局部变量保存在每个线程自己的栈中，也就意味着局部变量不会在线程之间共享，同时意味着所有基本类型的局部变量都是线程安全的。下面是一个线程安全的基本类型局部变量的例子：</p>
<blockquote>
<p><code>public void someMethod(){</code><br>　　<code>long threadSafeInt = 0;</code><br>　　<code>threadSafeInt++;</code><br><code>}</code>   </p>
</blockquote>
<h2 id="局部对象引用">局部对象引用</h2>
<p>　　<br>　　局部对象引用有一点不同，引用本身不会共享，但是被引用的对象不是保存在每个线程的局部栈中，所有的对象都保存在共享堆中。如果一个方法创建的局部对象并没有在其他方法被引用，那它是线程安全的。实际上你还可以把它传给另一个方法或者对象只要这些方法和对象不让其他线程获取到传过来的对象即可。下面是一个线程安全的局部对象例子：</p>
<blockquote>
<p><code>public void someMethod(){</code><br>　　<code>LocalObject localObject = new LocalObject();</code><br>　　<code>localObject.callMethod();</code><br>　　<code>method2(localObject);</code><br><code>}</code>  </p>
<p><code>public void method2(LocalObject localObject){</code><br>　　<code>localObject.setValue(&quot;value&quot;);</code><br><code>}</code>  </p>
</blockquote>
<p>　　这个例子中的LocalObject实例没有被返回也没有传递给可以从外部访问someMethod()方法的其他对象。每个执行someMethod()方法的线程都会创建自己的LocalObject实例并分配给localObject引用，所以这里LocalObject用法是线程安全的。实际上someMethod()整个方法都是线程安全。即使LocalObject实例被当作参数传递给同一类或者其他类中的其他方法，它也是线程安全的。但是唯一例外情况是一个把LocalObject 当作参数调用的方法，用允许其他线程访问它的方式保存LocalObject 实例。</p>
<h2 id="对象成员">对象成员</h2>
<p>　　对象成员与对象一起存储在堆里面，所以如果两个线程调用同一对象实例的一个方法并且这个方法修改对象的成员这个方法就不是线程安全的。下面是一个非线程安全的方法示例：</p>
<blockquote>
<p><code>public class NotThreadSafe{</code><br>　　<code>StringBuilder builder = new StringBuilder();</code>    </p>
<p>　　<code>public add(String text){</code><br>　　　　<code>this.builder.append(text);</code><br>　　<code>}</code><br><code>}</code>   </p>
</blockquote>
<p>　　如果两个线程同时调用同一个NotThreadSafe实例的add()方法就会引起竞态条件。比如：</p>
<blockquote>
<p><code>NotThreadSafe sharedInstance = new NotThreadSafe();</code>  </p>
<p><code>new Thread(new MyRunnable(sharedInstance)).start();</code><br><code>new Thread(new MyRunnable(sharedInstance)).start();</code>  </p>
<p><code>public class MyRunnable implements Runnable{</code><br>　　<code>NotThreadSafe instance = null;</code>  </p>
<p>　　<code>public MyRunnable(NotThreadSafe instance){</code><br>　　　　<code>this.instance = instance;</code><br>　　<code>}</code>  </p>
<p>　　<code>public void run(){</code><br>　　　　<code>this.instance.add(&quot;some text&quot;);</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　注意这两个MyRunnable实例共享了同一个NotThreadSafe实例，所以当它们调用NotThreadSafe实例的add()方法时会引起竞态条件。  </p>
<p>　　然而如果两个线程在不同的实例上面同时调用add()方法并不会引起静态条件。下面是稍微修改之后的例子：</p>
<blockquote>
<p><code>new Thread(new MyRunnable(new NotThreadSafe())).start();</code><br><code>new Thread(new MyRunnable(new NotThreadSafe())).start();</code>  </p>
</blockquote>
<p>　　现在这两个线程都有自己的NotThreadSafe实例，所以它们对add方法的调用并不会妨碍对方，这段代码没有竞态条件。所以即使一个对象不是线程安全的，仍可以找到一个方式来消除竞态条件。　</p>
<h2 id="线程控制逃逸规则">线程控制逃逸规则</h2>
<p>　　当需要判断你的代码访问某些资源是否是线程安全的时候你可以用线程控制逃逸规则：</p>
<blockquote>
<p><code>如果一个资源在一个线程的控制下被创建、使用和销毁并且永远不会逃脱线程的控制，则该资源的使用是线程安全的。</code>  </p>
</blockquote>
<p>　　资源可以是任何共享资源像对象、数组、文件、数据库连接、socket等等。java语言中不需要你明确的销毁对象，所以“被销毁”意味着对象的引用丢失了或者被置为null。  </p>
<p>　　即使对象的使用是线程安全的，如果这个对象包含共享资源（比如文件或者数据库连接）你的整个应用程序也不会是线程安全的。比如，如果线程1和线程2都创建了自己的数据库连接，连接1和连接2，每个连接自己本身的使用是线程安全的。但是这两个数据库连接指向的数据库使用时可能不是线程安全的。比如如果两个线程执行如下代码：
　　</p>
<blockquote>
<p><code>校验记录X是否存在，如果不存在插入一个记录X。</code>  </p>
</blockquote>
<p>　　如果两个线程同时执行这个代码，而且它们校验的记录X碰巧是同一个记录，就会存在这两个线程最终都插入记录X的风险。比如：
　　
　　</p>
<blockquote>
<p><code>线程1检查记录X是否存在，结果是否。</code><br><code>线程2检查记录X是否存在，结果是否。</code><br><code>线程1插入记录X。</code><br><code>线程2插入记录X。</code>  </p>
</blockquote>
<p>　　同样的问题也会发生在操作文件或者其它共享资源的线程上面。因此，区分一个线程控制的是资源本身，还是仅仅是资源的引用非常重要。</p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程安全" scheme="http://fantasynew.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="资源共享" scheme="http://fantasynew.github.io/tags/%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[竞态条件与临界区]]></title>
    <link href="http://fantasynew.github.io/2014/04/15/race-conditions-and-critical-sections/"/>
    <id>http://fantasynew.github.io/2014/04/15/race-conditions-and-critical-sections/</id>
    <published>2014-04-15T14:06:44.000Z</published>
    <updated>2014-04-26T10:43:13.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html</a></p>
<p>　　在一个应用程序中同时运行多个线程本身不会引起问题，问题出现在多个线程访问相同资源的时候，比如同一内存（变量，数组或者对象），系统（数据库，网络服务等等）或者文件。事实上，问题只出现在一个或者多个线程对这些资源进行写操作的时候。只要这些资源没有变化，多个线程对同一资源进行读操作是安全的。</p>
<p>　　下面是被多个线程同时执行时可能会失败的代码示例：
　　</p>
<blockquote>
<p><code>public class Counter {</code><br>　　<code>protected long count = 0;</code><br>　　<code>public void add(long value){</code><br>　　　　<code>this.count = this.count + value;</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　想象如果两个线程A和B在同一个Counter实例中执行这个add方法，我们无法知道操作系统什么时候在这两个线程之间进行切换。java虚拟机不会把这段代码作为单指令执行，而是按照下面的顺序执行：</p>
<blockquote>
<p><code>把this.count从内存中读取到寄存器</code><br><code>将寄存器中的值加1</code><br><code>把寄存器中的值写到内存中</code>  </p>
</blockquote>
<p>　　观察如果线程A和B混合执行会发生什么：</p>
<blockquote>
<p><code>this.count = 0;</code><br><code>A: 把this.count从内存中读取到寄存器(0)</code><br><code>B: 把this.count从内存中读取到寄存器(0)</code><br><code>B: 将寄存器中的值加2</code><br><code>B：把寄存器中的值2写到内存中，this.count的值是2</code><br><code>A：将寄存器中的值加3</code><br><code>A：把寄存器中的值3写到内存中，this.count的值是3</code>  </p>
</blockquote>
<p>　　这两个线程把数值2和3加到了counter上面，所以两个线程混合执行完成之后预期值应该是5。然而，由于两个线程的执行是交错的，这两个线程从内存中读取的都是0，接着它们分别加它们自己的值2和3并写回到内存中。取代5留在this.count的值会是最后一个线程写入的值。在上面的例子中是线程A，但是也可能是线程B，没有适当的线程同步机制我们没办法知道线程是如何交错执行的。</p>
<h2 id="竞态条件与临界区">竞态条件与临界区</h2>
<p>　　在两个线程竞争同一资源的情况下，资源访问的顺序非常重要的，被称作存在竞态条件。导致竞态条件出现的代码区域被称作临界区。在前一个例子中方法add()就是一个临界区，它导致了竞态条件。临界区里适当的线程同步可以避免竞态条件的发生。　</p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="竞态条件" scheme="http://fantasynew.github.io/tags/%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6/"/>
    
      <category term="临界区" scheme="http://fantasynew.github.io/tags/%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创建和启动java线程]]></title>
    <link href="http://fantasynew.github.io/2014/04/13/creating-and-starting-threads/"/>
    <id>http://fantasynew.github.io/2014/04/13/creating-and-starting-threads/</id>
    <published>2014-04-13T14:06:44.000Z</published>
    <updated>2014-04-26T10:42:49.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/creating-and-starting-threads.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/creating-and-starting-threads.html</a></p>
<p>　　java线程对象与其他java对象一样，所有的线程都继承java.lang.Thread类，或者java.lang.Thread的子类。除了作为对象，java线程还可以执行代码。</p>
<h2 id="创建启动线程">创建启动线程</h2>
<p>　　在java中可以用如下方式创建一个线程：
　　</p>
<blockquote>
<p><code>Thread thread = new Thread();</code>　　</p>
</blockquote>
<p>　　可以通过调用它的start()方法来启动这个线程，像这样：
　　</p>
<blockquote>
<p><code>thread.start();</code>　　</p>
</blockquote>
<p>　　这个例子并没有指定线程执行任何代码，调用完成之后它就会停止。  </p>
<p>　　有两种方式来指定线程执行代码。第一种是创建一个Thread 子类并且重写它的run()方法，第二种创建类时实现Runnable接口，下面会介绍这两种方法。</p>
<h2 id="Thread子类">Thread子类</h2>
<p>　　第一种指定线程执行代码的方式是创建一个Thread子类并重写它的run()方法,run()方法就是你的线程调用start()后执行的方法。例子如下：  </p>
<blockquote>
<p><code>public class MyThread extends Thread {</code><br>　　<code>public void run(){</code><br>　　　　<code>System.out.println(&quot;MyThread running&quot;);</code><br>　　<code>}</code><br><code>}</code>  </p>
</blockquote>
<p>　　你可以这样创建和启动上面的线程：</p>
<blockquote>
<p><code>MyThread myThread = new MyThread();</code><br><code>myTread.start();</code></p>
</blockquote>
<p>　　start()请求会在线程开始之后立刻返回，它不会等待run()方法执行完，run()方法就好像被另一个CPU执行一样。当run()方法执行时它会打印出文本“MyThread running”。</p>
<p>　　你还可以按照下面的方法创建一个Thread的匿名子类：
　　</p>
<blockquote>
<p><code>Thread thread = new Thread(){</code><br>　　<code>public void run(){</code><br>　　　　<code>System.out.println(&quot;Thread Running&quot;);</code><br>　　<code>}</code><br><code>}</code><br><code>thread.start();</code> </p>
</blockquote>
<p>　　一旦run()方法被这个新线程执行的时候这个例子就会打印出“Thread running”。</p>
<h2 id="实现Runnable接口">实现Runnable接口</h2>
<p>　　第二种指定线程执行代码的方式是创建一个实现了java.lang.Runnable接口的类。Runnable对象会被一个线程执行。  </p>
<p>　　下面是java实现Runnable接口的例子：
　　</p>
<blockquote>
<p><code>public class MyRunnable implements Runnable {</code><br>　　<code>public void run(){</code><br>　　　　<code>System.out.println(&quot;MyRunnable running&quot;);</code><br>　　<code>}</code><br><code>}</code>  　</p>
</blockquote>
<p>　　为了让run()方法被一个线程执行，需要把MyRunnable的实例对象传到Thread类的构造函数中。例子如下：
　　</p>
<blockquote>
<p><code>Thread thread = new Thread(new MyRunnable());</code><br><code>myTread.start();</code></p>
</blockquote>
<p>　　这个线程开始时他会调用MyRunnable实例对象的run()方法而不是执行它自己的run()方法。上例会打印出“MyRunnable running”。</p>
<p>　　同样，你也可以这样创建一个实现Runnable接口的匿名类：
　　</p>
<blockquote>
<p><code>Runnable myRunnable = new Runnable(){</code><br>　　<code>public void run(){</code><br>　　　　<code>System.out.println(&quot;Runnable running&quot;);</code><br>　　<code>}</code><br><code>}</code><br><code>Thread thread = new Thread(myRunnable);</code><br><code>thread.start();</code>　　</p>
</blockquote>
<h2 id="选择创建子类还是实现Runnable接口">选择创建子类还是实现Runnable接口</h2>
<p>　　这两种方式哪个好没有明确的答案，两种方式都能正常工作。就我个人而言，我喜欢实现Runnable接口，然后把它交给一个线程实例处理。因为实现Runnable接口的线程在线程池中很容易管理，当线程池中的线程有空闲时线程池很容易排列Runnable实例。这对于子类Thread 有一点点困难。</p>
<p>　　有时候你可能需要同时实现Runnable接口并且创建Thread子类。比如，创建一个Thread 子类运行多个实现Runnable接口的类，这常被用来实现一个线程池。
　　</p>
<h2 id="常见错误：调用run()方法而不是start()方法">常见错误：调用run()方法而不是start()方法</h2>
<p>　　当创建和启动一个线程时常犯的错误是直接调用Thread的run()方法而不是start()方法，像这样：
　　</p>
<blockquote>
<p><code>Thread thread = new Thread(new MyRunnable());</code><br><code>thread.run();  //should be start();</code></p>
</blockquote>
<p>　　起初你可能不会注意到任何异常因为run()方法按照你所期望的那样被执行了。然而它不是被你刚刚创建的新线程执行的，run()方法反而是被创建新线程的线程所执行的。换句话说，是被执行了上面两行代码的线程执行的。为了让新创建的线程执行MyRunnable 实例的run()方法，你必须调用新线程的start()方法。
　　</p>
<h2 id="线程名">线程名</h2>
<p>　　创建一个线程时你可以给它一个名称，线程名可以帮助你区别其它的线程。比如，如果多个线程都用System.out输出信息，可以很方便查出是哪个线程输出的信息。例子如下：
　　</p>
<blockquote>
<p><code>Thread thread = new Thread(&quot;New Thread&quot;) {</code><br>　　<code>public void run(){</code><br>　　　　<code>System.out.println(&quot;run by: &quot; + getname());</code><br>　　<code>}</code><br><code>}</code><br><code>thread.start();</code><br><code>System.out.println(thread.getName());</code>  </p>
</blockquote>
<p>　　注意字符串”New Thread”作为参数传给线程的构造函数，这个字符串就是线程名。这个线程名可以通过线程的getName()方法获得。使用实现Runnable 接口方式时你也可以给线程传递一个名称。例子如下：
　　</p>
<blockquote>
<p><code>MyRunnable runnable = new MyRunnable();</code><br><code>Thread thread = new Thread(runnable, &quot;New Thread&quot;);</code><br><code>thread.start();</code><br><code>System.out.println(thread.getName());</code> 　　</p>
</blockquote>
<p>　　不过请注意，既然MyRunnable类不是Thread的子类，它没有使用执行它的线程的getName()方法的权限。当前正在执行的线程引用可以使用下面的方式获得</p>
<blockquote>
<p><code>Thread.currentThread();</code>  </p>
</blockquote>
<p>　　获取当前正在执行线程名称的代码可以这样写：</p>
<blockquote>
<p><code>String threadName = Thread.currentThread().getName();</code></p>
</blockquote>
<h2 id="java线程实例">java线程实例</h2>
<p>　　这里有一个小例子。首先它打印出执行main()方法的线程的名称，这个线程是被JVM分配的。接着它开始10个线程并给它们一个数字作为线程名，每个线程都会打印出它们的名称并结束执行。</p>
<blockquote>
<p><code>public class ThreadExample {</code><br>　　<code>public static void main(String[] args){</code><br>　　　　<code>System.out.println(Thread.currentThread().getName());</code><br>　　　　<code>for(int i=0; i&lt;10; i++){</code><br>　　　　　　<code>new Thread(&quot;&quot; + i){</code><br>　　　　　　　　<code>public void run(){</code><br>　　　　　　　　　　<code>System.out.println(&quot;Thread: &quot; + getName() + &quot; running&quot;);</code><br>　　　　　　　　<code>}</code><br>　　　　　　<code>}.start();</code><br>　　　　<code>}</code><br>　　<code>}</code><br><code>}</code></p>
</blockquote>
<p>　　注意虽然这些线程是按照一定顺序(1、2、3…)启动的，它们可不会按照该顺序执行，也就是线程1可能不会作为第一个把自己名称输出到System.out的线程。因为这些线程原则上是并行执行的而不是顺序执行，JVM和/或操作系统决定线程的执行顺序，打印的顺序和开始的顺序并不一定是一致的。　</p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Thread类" scheme="http://fantasynew.github.io/tags/Thread%E7%B1%BB/"/>
    
      <category term="Runnable接口" scheme="http://fantasynew.github.io/tags/Runnable%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[多线程的代价]]></title>
    <link href="http://fantasynew.github.io/2014/04/11/costs-of-multithreading/"/>
    <id>http://fantasynew.github.io/2014/04/11/costs-of-multithreading/</id>
    <published>2014-04-11T14:06:44.000Z</published>
    <updated>2014-04-26T10:41:23.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/costs.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/costs.html</a></p>
<h2 id="简介">简介</h2>
<p>　　从单线程应用程序更新到多线程可不光带来优点，它也会付出一些代价。千万不要仅仅因为你可以使用多线程就给应用程序添加多线程。你应该明确的知道使用多线程带来的好处比所付出的代价多的时候才可以使用多线程。有疑问时，试着衡量应用程序的性能和响应时间，不要只是简单的猜想。</p>
<h2 id="更复杂的设计">更复杂的设计</h2>
<p>　　尽管多线程应用程序的某些部分比单线程应用程序简单，但是其他部分更为复杂。被多个线程执行的代码在访问共享数据的时候需要特别注意。线程交互可不总是那么简单，不正确的线程同步引起的错误可能更难测试、复现和修改。</p>
<h2 id="上下文切换的开销">上下文切换的开销</h2>
<p>　　当CPU从一个线程的执行切换到另一个时，CPU需要保存当前线程的本地数据，程序指针等，并且加载下一个线程的本地数据，程序指针来继续执行，这个切换被称作“上下文切换”。CPU从一个线程的上下文的执行切换到另一个线程的上下文中。  </p>
<p>　　上下文切换并不廉价，如果没有必要应该减少线程之间的上下文切换。</p>
<p>　　可以在维基上面看到更多关于上下文切换的信息：
　　</p>
<blockquote>
<p><a href="http://en.wikipedia.org/wiki/Context_switch" target="_blank">http://en.wikipedia.org/wiki/Context_switch</a></p>
</blockquote>
<h2 id="增加资源消耗">增加资源消耗</h2>
<p>　　一个线程需要从计算机中获得一些资源来保证运行。除了CPU时间段线程还需要一些内存来保存它的本地堆栈，还需要一些操作系统中的资源来管理线程。试着创建一个程序，让它创建100个线程，这些线程什么都不做只是等待的，然后看看当这个应用程序运行时有多少内存被占用。  </p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="资源消耗" scheme="http://fantasynew.github.io/tags/%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97/"/>
    
      <category term="上下文切换" scheme="http://fantasynew.github.io/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[多线程的优点]]></title>
    <link href="http://fantasynew.github.io/2014/04/09/multithreading-benefits/"/>
    <id>http://fantasynew.github.io/2014/04/09/multithreading-benefits/</id>
    <published>2014-04-09T14:06:44.000Z</published>
    <updated>2014-04-26T10:42:24.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/benefits.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/benefits.html</a></p>
<h2 id="简介">简介</h2>
<p>　　尽管有许多挑战，多线程仍然被使用的原因是它有几个优点，这些优点是：</p>
<blockquote>
<ul>
<li>更好的资源利用率。 </li>
<li>在某些情况下程序设计的更简单。</li>
<li>程序响应很快。</li>
</ul>
</blockquote>
<h2 id="更好的资源利用率">更好的资源利用率</h2>
<p>　　想象一个从本地文件系统中读取和处理文件的应用程序。假设从硬盘读取一个文件需要5秒，处理它需要2秒。处理两个文件则需要:</p>
<blockquote>
<p>　　<code>5秒读取文件A</code><br>　　<code>2秒处理文件A</code><br>　　<code>5秒读取文件B</code><br>　　<code>2秒处理文件B</code>  </p>
<hr>
<p>　　<code>总共14秒</code></p>
</blockquote>
<p>　　当从硬盘中读取文件时，大部分的CPU时间花费在等待硬盘读取数据上面了。这段时间里CPU处于绝对空闲状态，它可以做一些其他事情。通过改变操作的顺序，CPU可以得到更有效地利用。看下面的顺序：
　　</p>
<blockquote>
<p>　　<code>5秒读取文件A</code><br>　　<code>5秒钟读取文件B + 2秒钟处理文件A</code><br>　　<code>2秒处理文件B</code>  </p>
<hr>
<p>　　<code>总共12秒</code>  </p>
</blockquote>
<p>　　CPU等待第一个文件的读取，接着开始读取第二个文件，当读取第二个文件的过程中CPU处理第一个文件。记住，在等待磁盘读取文件的时候CPU处于绝对空闲状态。</p>
<p>　　一般而言，CPU可以在等待IO的过程中做其他事情。不必非得磁盘的IO，还可以是网络IO，或者是用户的输入。网络和硬盘的IO通常都比CPU和内存的IO慢很多。　　</p>
<h2 id="更简单的程序设计">更简单的程序设计</h2>
<p>　　在单线程应用程序中如果你想编程实现上面提到的读取和处理功能，你必须跟踪每个文件的读取和处理状态。相反，你可以启动两个线程，每个线程负责一个文件的读取和处理。每个线程在等待硬盘读取它所需要的文件过程中都会堵塞，等待过程中其他线程可以使用CPU来处理他们已经读取过来的文件。导致的结果是硬盘一直处在忙碌状态，不断的读取不同的文件到内存中，这样就使硬盘和CPU都得到了有效利用。这也很好设计，因为每个线程只需要跟踪一个文件。  
　　</p>
<h2 id="程序响应更快">程序响应更快</h2>
<p>　　把单线程应用程序替换成多线程应用程序的另一个常见原因是想获得响应更快的应用程序。想象一个服务器应用在一些端口监听传入的请求。当一个请求到达后，它处理这个请求然后回去继续监听。这个服务器的循环流程概述如下：</p>
<blockquote>
<p><code>while(server is active){</code><br>　　<code>listen for request</code><br>　　<code>hand request to worker thread</code><br><code>}</code>  </p>
</blockquote>
<p>　　如果一个请求需要花费很长的时间来处理，在这段时间内新的客户端就无法发送请求给服务器。只有在服务器监听的时候请求才能被接收到。  </p>
<p>　　另一个设计方法是监听线程把请求传递给响应线程，然后立刻返回到监听状态。响应线程负责处理请求并给客户端发送一个回复。这个设计概述如下：  </p>
<blockquote>
<p><code>while(server is active){</code><br>　　<code>listen for request</code><br>　　<code>hand request to worker thread</code><br><code>}</code>  </p>
</blockquote>
<p>　　这个方式下，服务器线程可以很快回到监听状态，因此更多的客户端可以发送请求到服务器，这个服务也变得响应更快。  </p>
<p>　　桌面应用程序同样如此，如果你点击一个按钮就开启一个耗时的任务，并且执行这个任务的线程同时负责刷新窗口和按钮，那么在这个任务执行过程中这个应用程序会显示无响应的。相反，这个任务可以交给一个响应线程来处理，当响应线程在处理这个任务的时候，窗口线程可以自由响应其他的用户请求。当响应线程结束的时候它会通知窗口线程，窗口线程就会根据任务的结果来更新应用程序窗口。用户的角度看这种具有响应线程的程序会显得响应速度很快。</p>
]]></content>
    
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="资源利用率" scheme="http://fantasynew.github.io/tags/%E8%B5%84%E6%BA%90%E5%88%A9%E7%94%A8%E7%8E%87/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发介绍]]></title>
    <link href="http://fantasynew.github.io/2014/04/07/introduction-to-java-concurrency/"/>
    <id>http://fantasynew.github.io/2014/04/07/introduction-to-java-concurrency/</id>
    <published>2014-04-07T14:06:44.000Z</published>
    <updated>2014-04-26T10:41:42.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/index.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/index.html</a></p>
<h2 id="引子">引子</h2>
<p>　　过去一台计算机只有单个CPU，每次只能执行一个程序。后来的计算机可以支持多任务处理，意味着它们可以同时执行多个程序（即任务或流程）。虽然不是真正意义上的“同时”，而是多个程序共享一个CPU，并交给操作系统在执行中的程序间进行切换，以保证每个程序在切换过程中都能得到一定的执行时间。  <a id="more"></a></p>
<p>　　多任务处理技术给软件开发人员带来了新的挑战。程序不能被假设占用所有的CPU可用时间、所有的内存和其它资源。一个“表现良好”的程序应该在不用这些资源的时候对其释放，以保证其它程序的使用。  </p>
<p>　　再后来出现了多线程技术，使得你可以在一个程序内部并行执行多个线程。一个线程的执行可以被认为是一个CPU在执行该程序。当你在一个程序内部执行多个线程时，就好像有多个CPU在同时执行该程序。  </p>
<p>　　多线程比多任务处理更具挑战性，这些线程运行在一个程序里因此会对相同的内存块进行并发读写操作，这可能导致一些在单线程程序里没出现过的错误。这些错误之所以没出现在单CPU的机器中是因为两个线程永远都不会真正意义上“并发”执行。但是伴随着现代多核CPU计算机的出现，也就意味着不同线程可以在不同CPU内核中得到真正意义上的并行执行。  </p>
<p>　　如果一个线程对一个内存块进行读取的时候，另一个线程对它进行写操作，进行第一个线程读出的值应该是哪个？写操作之前的旧值？第二个线程写入的新值？还是这两个值之间的混合值？如果两个线程同时对同一内存块进行写操作，当它们写操作完成之后内存块里的值应该是哪个？第一个线程写入的值？第二个线程写入的值？还是这两个值之间的混合值？没有适当的防护措施任何输出结果都是可能的，这种行为甚至都不可预测，输出结果可以随时改变。  </p>
<h2 id="Java的多线程和并发">Java的多线程和并发</h2>
<p>　　Java是最先支持多线程开发的编程语言之一，java一开始就提供了多线程开发的功能。因此，java开发者们经常会碰到上面提到的那些问题。这就是我写这篇java并发系列的原因，作为自己的笔记，希望其它java开发人员都可从中受益。  </p>
<p>　　这个博客系列主要是关心java的多线程开发，但是多线程中出现的一些问题与多任务处理和分布式系统中出现的问题存在类似，因此这个博客系列会将多任务处理和分布式系统作为参考，所以叫法上称为“并发性”而不是“多线程”。  </p>
<p>　　这个博客系列仍在继续更新中，只要有时间写我就会把新文章更新出来。下表是已经更新的文章：
　　</p>
<h3 id="Java并发">Java并发</h3>
<ul>
<li><a href="http://fantasynew.github.io/2014/04/21/introduction-to-java-concurrency/">java并发介绍</a></li>
<li><a href="http://fantasynew.github.io/2014/04/09/multithreading-benefits/">多线程的优点</a></li>
<li><a href="http://fantasynew.github.io/2014/04/11/costs-of-multithreading/">多线程的代价</a></li>
<li><a href="http://fantasynew.github.io/2014/04/13/creating-and-starting-threads/">创建和启动java线程</a></li>
<li><a href="http://fantasynew.github.io/2014/04/15/race-conditions-and-critical-sections/">竞态条件与临界区</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>原文地址：<a href="http://tutorials.jenkov.com/java-concurrency/index.html" target="_blank">http://tutorials.jenkov.com/java-concurrency/index.html</a></p>
<h2 id="引子">引子</h2>
<p>　　过去一台计算机只有单个CPU，每次只能执行一个程序。后来的计算机可以支持多任务处理，意味着它们可以同时执行多个程序（即任务或流程）。虽然不是真正意义上的“同时”，而是多个程序共享一个CPU，并交给操作系统在执行中的程序间进行切换，以保证每个程序在切换过程中都能得到一定的执行时间。  ]]></summary>
    
      <category term="java" scheme="http://fantasynew.github.io/tags/java/"/>
    
      <category term="多线程" scheme="http://fantasynew.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://fantasynew.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java多线程" scheme="http://fantasynew.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://fantasynew.github.io/2014/04/01/hello-world/"/>
    <id>http://fantasynew.github.io/2014/04/01/hello-world/</id>
    <published>2014-04-01T14:06:44.000Z</published>
    <updated>2014-04-22T13:40:13.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io" target="_blank">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs" target="_blank">documentation</a> to learn how to use.</p>
]]></content>
    
    
      <category term="杂乱" scheme="http://fantasynew.github.io/categories/%E6%9D%82%E4%B9%B1/"/>
    
  </entry>
  
</feed>
